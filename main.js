/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagAgent
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/services/tagGenerator.ts
var import_ollama = require("@langchain/community/llms/ollama");
var import_prompts = require("@langchain/core/prompts");
var http = __toESM(require("http"));
var TagGenerator = class {
  constructor(baseUrl, modelName) {
    this.model = new import_ollama.Ollama({
      baseUrl,
      model: modelName,
      temperature: 0.7
    });
    this.promptTemplate = import_prompts.PromptTemplate.fromTemplate(
      `Given the following note content, suggest 3-5 relevant tags that capture the main topics and themes. Tags should start with '#' and be concise. If any of the suggested tags already exist in the note, prioritize them. Avoid overly generic tags.

Note Content:
{content}

Existing Tags:
{existingTags}

Please provide the tags as a comma-separated list.`
    );
  }
  async isOllamaServerRunning() {
    return new Promise((resolve) => {
      const req = http.get(this.model.baseUrl + "/api/version", (res) => {
        resolve(res.statusCode === 200);
      });
      req.on("error", () => {
        resolve(false);
      });
      req.end();
    });
  }
  async suggestTags(content, existingTags = /* @__PURE__ */ new Set(), signal) {
    const isServerRunning = await this.isOllamaServerRunning();
    if (!isServerRunning) {
      throw new Error('Ollama server is not running. Please start the Ollama server using the command: "ollama serve"');
    }
    const existingTagsList = Array.from(existingTags).join(", ");
    try {
      if (signal == null ? void 0 : signal.aborted) {
        throw new Error("Operation cancelled");
      }
      const prompt = await this.promptTemplate.format({
        content,
        existingTags: existingTagsList || "None"
      });
      const response = await this.model.invoke(prompt, {
        signal
      });
      return response.split(",").map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0).map((tag) => tag.replace(/\s+/g, "-"));
    } catch (error) {
      if (error.name === "AbortError" || error.message === "Operation cancelled") {
        console.log("Tag generation cancelled");
        return [];
      }
      throw error;
    }
  }
};

// src/main.ts
var TagAgent = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.abortController = null;
  }
  async onload() {
    this.tagGenerator = new TagGenerator("http://localhost:11434", "llama3.1");
    const ribbonIconEl = this.addRibbonIcon("tag", "Tag Agent", (evt) => {
      this.activateTagAgent();
    });
    ribbonIconEl.addClass("tag-agent-ribbon-class");
    this.addCommand({
      id: "suggest-tags",
      name: "Suggest Tags",
      callback: () => {
        this.activateTagAgent();
      }
    });
  }
  onunload() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }
  async activateTagAgent() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return;
    }
    if (this.abortController) {
      this.abortController.abort();
    }
    this.abortController = new AbortController();
    try {
      const fileContent = await this.app.vault.read(activeFile);
      const existingTags = this.getExistingTags(activeFile);
      const suggestedTags = await this.tagGenerator.suggestTags(
        fileContent,
        existingTags,
        this.abortController.signal
      );
      if (suggestedTags.length > 0) {
        const tagsToAdd = suggestedTags.filter((tag) => !existingTags.has(tag));
        if (tagsToAdd.length > 0) {
          await this.appendTagsToFile(activeFile, tagsToAdd);
        } else {
          this.displayNotice("No new tags to suggest.");
        }
      }
    } catch (error) {
      if (error.name !== "AbortError") {
        console.error("Error suggesting tags:", error);
        this.displayNotice("Error suggesting tags. Please check the console for details.");
      }
    } finally {
      this.abortController = null;
    }
  }
  getExistingTags(file) {
    var _a;
    const existingTags = /* @__PURE__ */ new Set();
    const cache = this.app.metadataCache.getFileCache(file);
    if (cache == null ? void 0 : cache.tags) {
      cache.tags.forEach((tagCache) => existingTags.add(tagCache.tag));
    }
    if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags) {
      const frontmatterTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
      frontmatterTags.forEach((tag) => existingTags.add(`#${tag}`));
    }
    return existingTags;
  }
  async appendTagsToFile(file, tags) {
    try {
      const content = await this.app.vault.read(file);
      const newContent = this.addTagsToContent(content, tags);
      await this.app.vault.modify(file, newContent);
      this.displayNotice(`Added tags: ${tags.join(", ")}`);
    } catch (error) {
      console.error("Error appending tags:", error);
      this.displayNotice("Error adding tags to file.");
    }
  }
  addTagsToContent(content, tags) {
    if (!content.trim()) {
      return tags.join(" ");
    }
    return `${content}
${tags.join(" ")}`;
  }
  displayNotice(message) {
    this.app.workspace.trigger("tag-agent:notice", message);
  }
};
